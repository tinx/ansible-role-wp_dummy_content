#!/usr/bin/python

ANSIBLE_METADATA = {
    'metadata_version': '1.1',
    'status': ['preview'],
    'supported_by': 'community'
}

DOCUMENTATION = '''
---
module: wp_dummy_content

short_description: Create dummy content in WordPress blogs

version_added: "2.4"

description:
    - "The module can be used to generate dummy content in WordPress
       blogs. A number of posts, pages and comments can be created
       and populated with filler texts. Optionally, previous content
       can be nuked or preserved. It is also possible to remove all
       generated content again."

options:
    url:
        required: true
        description:
            - The URL of the blog to modify.
    username:
        required: true
        description:
            - The WordPress username to use for authentication.
    password:
        required: true
        description:
            - The WordPress password to use for authentication.
    pages:
        required: false
        default: '5-100+'
        description:
            - Value range for the amount of pages the blog should have.
              This is a string value, not a number. See I(Notes) for
              more information.
    posts:
        required: false
        default: '5-100+'
        description:
            - Value range for the amount of posts the blog should have.
              This is a string value, not a number. See I(Notes) for
              more information.
    comments:
        required: false
        default: '1-30+'
        description:
            - Value range for the amount of comments for each page and post.
              This is a string value, not a number. See I(Notes) for
              more information.
    state:
        required: false
        choices: [ "present", "absent", "fresh" ]
        default: "present"
        description:
            - Specifying C(state=absent) will remove all auto-generated
              dummy content from previous plays. Specifying C(state=fresh)
              forces replacement of previously generated dummy content
              with new dummy content. Always results in an Ansible
              C(changed) state. However, this does not affect content
              generated by other means. Use the '!' range modifier for that.

notes:
    - Value ranges contain a minimum and maximum number of items, seperated
      by a dash. If a value range begins with a C('!') character all previously
      existings items will be removed. If a value range ends with a C('+')
      character pre-existing extra items (beyond the specified maximum)
      will not be removed. This is useful if you wish to mix auto-generated
      content into a pre-filled blog without risk of deleting existing
      data.
    - Examples: C('!5') replaces whatever exists with exactly five items of
      dummy content. C('3-20+) retains whatever items already exist, even
      if there are more than 20, but otherwise will make sure there are
      between three and 20 items of this type in total.

author:
    - Andreas Jaekel (@tinx)
'''

EXAMPLES = '''
# Replace all pages with new nonsense:
- name: Re-generate pages (always returns 'changed')
  wp_dummy_content:
    url: 'https://blog.example.com/'
    username: 'foo'
    password: 'bar'
    pages: '!5-10'

# Wipe a WordPress blog clean of content
- name: Remove all content
  wp_dummy_content:
    url: 'https://blog.example.com/'
    username: 'foo'
    password: 'bar'
    posts: '0'
    pages: '0'

# Make sure there are exactly 20 pages, but keep whatever is already there
- name: Grow to exactly 20 pages unless more already exist
  wp_dummy_content:
    url: 'https://blog.example.com/'
    username: 'foo'
    password: 'bar'
    pages: '20+'

# Remove all content generated with this module
- name: Remove dummy content
  wp_dummy_content:
    url: 'https://blog.example.com/'
    username: 'foo'
    password: 'bar'
    state: absent
'''

RETURN = '''
pages:
    description:
      - A dict indicating the number of pages in the blog by source, as
        well as the changes caused by this execution.
    type: dict of integers
    sample: C({ total: 20, dummy: 14, genuine: 6, added: 14, removed: 0 })
    returned: on success
posts:
    description:
      - A dict indicating the number of posts in the blog by source, as
        well as the changes caused by this execution.
    type: dict of integers
    sample: C({ total: 7, dummy: 0, genuine: 7, added: 0, removed: 12 })
    returned: on success
comments:
    description:
      - A dict indicating the number of posts in the blog by source,
        as a total over all posts and pages, as well as the changes caused
        by this execution.
    type: dict of integers
    sample: C({ total: 173, dummy: 51, genuine: 122, added: 20, removed: 5 })
    returned: on success
'''

from ansible.module_utils.basic import AnsibleModule
import xmlrpclib
import random
import re

lipsum_words = []
lipsum_init = False

def lorem_init():
    global lipsum_words
    global lipsum_init
    lipsum = """
        Non eram nescius, Brute, cum, quae summis ingeniis exquisitaque
        doctrina philosophi Graeco sermone tractavissent, ea Latinis litteris
        mandaremus, fore ut hic noster labor in varias reprehensiones
        incurreret. nam quibusdam, et iis quidem non admodum indoctis, totum
        hoc displicet philosophari. quidam autem non tam id reprehendunt, si
        remissius agatur, sed tantum studium tamque multam operam ponendam in
        eo non arbitrantur. erunt etiam, et ii quidem eruditi Graecis
        litteris, contemnentes Latinas, qui se dicant in Graecis legendis
        operam malle consumere. postremo aliquos futuros suspicor, qui me ad
        alias litteras vocent, genus hoc scribendi, etsi sit elegans, personae
        tamen et dignitatis esse negent.

        Contra quos omnis dicendum breviter existimo. Quamquam philosophiae
        quidem vituperatoribus satis responsum est eo libro, quo a nobis
        philosophia defensa et collaudata est, cum esset accusata et
        vituperata ab Hortensio. qui liber cum et tibi probatus videretur et
        iis, quos ego posse iudicare arbitrarer, plura suscepi veritus ne
        movere hominum studia viderer, retinere non posse. Qui autem, si
        maxime hoc placeat, moderatius tamen id volunt fieri, difficilem
        quandam temperantiam postulant in eo, quod semel admissum coerceri
        reprimique non potest, ut propemodum iustioribus utamur illis, qui
        omnino avocent a philosophia, quam his, qui rebus infinitis modum
        constituant in reque eo meliore, quo maior sit, mediocritatem
        desiderent.

        Sive enim ad sapientiam perveniri potest, non paranda nobis solum ea,
        sed fruenda etiam [sapientia] est; sive hoc difficile est, tamen nec
        modus est ullus investigandi veri, nisi inveneris, et quaerendi
        defatigatio turpis est, cum id, quod quaeritur, sit pulcherrimum.
        etenim si delectamur, cum scribimus, quis est tam invidus, qui ab eo
        nos abducat? sin laboramus, quis est, qui alienae modum statuat
        industriae? nam ut Terentianus Chremes non inhumanus, qui novum
        vicinum non vult 'fodere aut arare aut aliquid ferre denique' -- non
        enim illum ab industria, sed ab inliberali labore deterret --, sic
        isti curiosi, quos offendit noster minime nobis iniucundus labor.

        Sed ut perspiciatis, unde omnis iste natus error sit voluptatem
        accusantium doloremque laudantium, totam rem aperiam eaque ipsa, quae
        ab illo inventore veritatis et quasi architecto beatae vitae dicta
        sunt, explicabo. nemo enim ipsam voluptatem, quia voluptas sit,
        aspernatur aut odit aut fugit, sed quia consequuntur magni dolores
        eos, qui ratione voluptatem sequi nesciunt, neque porro quisquam est,
        qui dolorem ipsum, quia dolor sit, amet, consectetur, adipisci velit,
        sed quia non numquam eius modi tempora incidunt, ut labore et dolore
        magnam aliquam quaerat voluptatem. ut enim ad minima veniam, quis
        nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut
        aliquid ex ea commodi consequatur? quis autem vel eum iure
        reprehenderit, qui in ea voluptate velit esse, quam nihil molestiae
        consequatur, vel illum, qui dolorem eum fugiat, quo voluptas nulla
        pariatur?
        """
    lipsum_words = lipsum.split();
    lipsum_init = True

def lorem(words, insert_links):
    global lipsum_words
    global lipsum_init

    if lipsum_init is False:
        lorem_init()

    text = ""
    total_words = len(lipsum_words)
    offset = random.randint(0, len(lipsum_words))
    for i in range(0, words):
         if text != "":
             text += " "
         text += lipsum_words[(offset + i) % total_words]
         if insert_links and random.randint(0, 20) == 20:
             link_text = lorem(random.randint(1, 3), False)
             text += " <a href=\"https://dummy_content.example.com/"
             text += str(random.randint(0, 10000))
             text += "/index.html\">" + link_text + "</a>"
    return text

def generate_paragraph():
    return lorem(random.randint(2, 200), True)

def generate_body(paragraphs):
    body = ""
    for i in range(0, random.randint(1, paragraphs)):
        body += "<p>" + generate_paragraph() + "</p>\n"
    return body

def generate_title():
    return lorem(random.randint(2, 8), False)

def parse_value_range(module, param, key):
    """Parse Ansible parameter value concerning the amount of items."""
    # Case: state=absent, remove all dummy content.
    if module.params['state'] == "absent":
        param[key]['flush'] = False
        param[key]['minimum'] = 0
        param[key]['maximum'] = 0
        param[key]['keep_extra'] = True
        return
    # Notmal case: some value range.
    m = re.match(r"^([!]?)(\d+)-(\d+)([+]?)$", module.params[key + 's'])
    if m is not None:
        param[key]['flush'] = (m.group(1) == '!')
        param[key]['minimum'] = int(m.group(2))
        param[key]['maximum'] = int(m.group(3))
        param[key]['keep_extra'] = (m.group(4) == '+')
    else:
        m = re.match(r"^([!]?)(\d+)([+]?)$", module.params[key + 's'])
        param[key]['flush'] = (m.group(1) == '!')
        param[key]['minimum'] = int(m.group(2))
        param[key]['maximum'] = int(m.group(2))
        param[key]['keep_extra'] = (m.group(3) == '+')

def parse_value_ranges(module):
    param = dict(
        page = dict(),
        post = dict(),
        comment = dict(),
    )
    parse_value_range(module, param, 'post')
    parse_value_range(module, param, 'page')
    parse_value_range(module, param, 'comment')
    return param

def generate_post(module, wp_api, ranges, post_type):
    """Generate a single new post."""
    subject = "[DummyContent] "+generate_title()
    content = generate_body(10)
    if module.check_mode:
        return
    wp_api.wp.newPost(1, module.params['username'],
                         module.params['password'],
                         {
                             "post_title": subject,
                             "post_content": content,
                             "post_status": "publish",
                             "post_type": post_type,
                             "comment_status": "open"
                         })

def generate_comment(module, wp_api, ranges, post):
    """Generate a single new comment for this post."""
    content = "[DummyContent] "+generate_body(3)
    content += str(random.randint(0, 100000))
    if module.check_mode:
        return
    wp_api.wp.newComment(1, module.params['username'],
                            module.params['password'],
                            post['post_id'],
                            {
                                "content": content,
                            })

def trash_posts(module, wp_api, posts):
    """Move posts into the WordPress trash. Note: there is currently no
       way to empty the trash using the WordPress XML-RPC API, nor can
       we use force_delete=True."""
    if module.check_mode:
        return
    for post in posts:
        wp_api.wp.deletePost(1, module.params['username'],
                                module.params['password'],
                                post["post_id"])

def trash_comments(module, wp_api, comments):
    """Move all comments in the list to the trash. Unfortunately, there
       is no way to empty the trash or permamnemtly remove comments using
       the RPC-XML API."""
    if module.check_mode:
        return
    for comment in comments:
        # Skip children. They will be deleted with their parent.
        if comment['parent'] != 0:
            next
        wp_api.wp.deleteComment(1, module.params['username'],
                                   module.params['password'],
                                   comment["comment_id"])

def get_all_posts(module, wp_api, post_type):
    """Get a list of all published posts of the given type in the blog.
       WordPress does not offer a way to get all posts in one call. The php
       function accepts "-1" as "no limit", but this does not work
       via XML-RPC."""
    posts = []
    offset = 0;
    while True:
        next_batch = wp_api.wp.getPosts(1, module.params['username'], 
                                           module.params['password'],
                                           { "post_type": post_type,
                                             "post_status": "publish",
                                             "number": 100,
                                             "offset": offset },
                                           ['post_title', 'comment_status'])
        if len(next_batch) <= 0:
            break
        posts += next_batch
        offset += 100
    return posts

def get_all_comments_for_post(module, wp_api, post):
    """Get a list of all comments of the given post.
       WordPress does not offer a way to get all comments in one call. The php
       function accepts "-1" as "no limit", but this does not work
       via XML-RPC."""
    comments = []
    offset = 0;
    while True:
        next_batch = wp_api.wp.getComments(1, module.params['username'], 
                                              module.params['password'],
                                              { "post_id": post['post_id'],
                                                "number": 100,
                                                "offset": offset })
        if len(next_batch) <= 0:
            break
        comments += next_batch
        offset += 100
    return comments


def generate_posts(module, wp_api, ranges, post_type):
    """Make sure the blog has the right amount of posts of the given type."""
    desired_amount = random.randint(ranges[post_type]['minimum'],
                                    ranges[post_type]['maximum'])

    posts = get_all_posts(module, wp_api, post_type)
    removed = 0
    # Should we remove all currently existing posts of this type?
    if ranges[post_type]['flush']:
        removed = len(posts)
        trash_posts(module, wp_api, posts);
        posts = [];

    dummy_posts = list(filter(
        lambda x: '[DummyContent]' in x['post_title'], posts))
    genuine_posts = list(filter(
        lambda x: '[DummyContent]' not in x['post_title'], posts))

    # "Throw away all that old dummy content. I want NEW dummy content!!!"
    if module.params['state'] == 'fresh':
        for post in dummy_posts:
            posts.remove(post)
            removed += 1
        trash_posts(module, wp_api, dummy_posts);
        dummy_posts = []

    # Prepare report, as far as we know how.
    report = dict(
        total = len(posts),
        dummy = len(dummy_posts),
        genuine = len(genuine_posts),
        added = 0,
        removed = removed
    )

    to_generate = desired_amount - len(posts)
    if to_generate == 0:
        # We're done.
        return report

    if to_generate > 0:
        # more content desired
        for i in range(0, to_generate):
            generate_post(module, wp_api, ranges, post_type)
            report['added'] += 1
            report['dummy'] += 1
            report['total'] += 1
    else:
        # We are asked to remove some posts.
        # Preferably remove previously generated dummy content.
        # Need to remove more? Well, ok, remove 'genuine' content, too.
        while len(posts) > desired_amount:
            if len(dummy_posts) > 0:
                idx = random.randint(0, len(dummy_posts) - 1)
                post = dummy_posts[idx]
                dummy_posts.remove(post)
                report['dummy'] -= 1
            else:
                if ranges[post_type]['keep_extra']:
                    break
                idx = random.randint(0, len(genuine_posts) - 1)
                post = genuine_posts[idx]
                genuine_posts.remove(post)
                report['genuine'] -= 1
            posts.remove(post)
            trash_posts(module, wp_api, [ post ]);
            report['removed'] += 1
            report['total'] -= 1

    return report

def generate_comments(module, wp_api, ranges):
    """Make sure all pages and posts have the right amount of comments."""
    posts = get_all_posts(module, wp_api, 'post')
    pages = get_all_posts(module, wp_api, 'page')
    all_posts = posts + pages

    report = dict(
        total = 0,
        dummy = 0,
        genuine = 0,
        added = 0,
        removed = 0
    )

    for post in all_posts:
        # This will lead to wrong report numbers for the amount
        # of existing posts, but we are really only interested in
        # posts that can be commented on.
        if post['comment_status'] != "open":
            continue

        comments = get_all_comments_for_post(module, wp_api, post)
        dummy_comments = list(filter(
            lambda x: '[DummyContent]' in x['content'], comments))
        genuine_comments = list(filter(
            lambda x: '[DummyContent]' not in x['content'], comments))

        # "Throw away all that old dummy content. I want NEW dummy content!!!"
        if module.params['state'] == 'fresh':
            for comment in dummy_comments:
                comments.remove(comment)
                report['removed'] += 1
            trash_comments(module, wp_api, dummy_comments);
            dummy_comments = []

        desired_amount = random.randint(ranges['comment']['minimum'],
                                        ranges['comment']['maximum'])

        # Should we remove existing comments of this post?
        if ranges['comment']['flush']:
            trash_comments(module, wp_api, comments)
            report['removed'] += len(comments)
            comments = dummy_comments = genuine_comments = []
        else:
            report['total'] += len(comments)
            report['dummy'] += len(dummy_comments)
            report['genuine'] += len(genuine_comments)

        if len(comments) == desired_amount:
            continue

        # Is there too much content?
        while len(comments) > desired_amount:
            # We are asked to remove some comments.
            # Preferably remove previously generated dummy content.
            # Need to remove more? Well, ok, remove 'genuine' content, too.
            if len(dummy_comments) > 0:
                idx = random.randint(0, len(dummy_comments) - 1)
                comment = dummy_comments[idx]
                dummy_comments.remove(comment)
                report['dummy'] -= 1
            else:
                if ranges['comment']['keep_extra']:
                    break
                idx = random.randint(0, len(genuine_comments) - 1)
                comment = genuine_comments[idx]
                genuine_comments.remove(comment)
                report['genuine'] -= 1
            comments.remove(comment)
            trash_comments(module, wp_api, [ comment ]);
            report['removed'] += 1
            report['total'] -= 1

        # more content desired?
        for i in range(0, (desired_amount - len(comments))):
            generate_comment(module, wp_api, ranges, post)
            report['added'] += 1
            report['dummy'] += 1
            report['total'] += 1

    return report

def run_module():
    """Entry point for Ansible. Must parse parameters and provide
       Ansible-compatible return values."""

    # set up Ansible framework and define module parameters
    module_args = dict(
        url = dict(type = 'str', required = True),
        username = dict(type = 'str', required = True),
        password = dict(type = 'str', required = True, no_log = True),
        pages = dict(type = 'str', default = '5-100+'),
        posts = dict(type = 'str', default = '5-100+'),
        comments = dict(type = 'str', default = '1-30+'),
        state = dict(
            choices = ['present', 'absent', 'fresh'],
            default = 'present')
    )
    result = dict(
        changed = False,
        msg = 'initial dummy content message'
    )
    module = AnsibleModule(
        argument_spec = module_args,
        supports_check_mode = True
    )

    # Perform the actual function or this module.
    wp_api = xmlrpclib.ServerProxy('%s/xmlrpc.php' % module.params['url'],
                                   use_datetime=True)
    ranges = parse_value_ranges(module)
    result['posts'] = generate_posts(module, wp_api, ranges, 'post')
    result['pages'] = generate_posts(module, wp_api, ranges, 'page')
    result['comments'] = generate_comments(module, wp_api, ranges)
    result['ranges'] = ranges

    # Did we change anything?
    if result['posts']['added'] or result['posts']['removed'] or \
       result['pages']['added'] or result['pages']['removed'] or \
       result['comments']['added'] or result['comments']['removed']:
        result['changed'] = True

    module.exit_json(**result)

def main():
    run_module()

if __name__ == '__main__':
    main()

